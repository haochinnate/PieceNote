# Chapter 04: DI設計模式

### DI 基本設計模式

- 組合根(Composition Root): 告訴你應該在何處、以及如何組合出應用程式的物件關聯
- 建構子注入(Constructor Injection): 讓類別可以用靜態的方式定義其依賴關係需求
- 方法注入(Method Injection): 在使用方對__依賴關係__的對象需求可能會__隨每次作業而有所不同__時, 可以用這種方式來滿足使用方的依賴關係
- 屬性注入(Property Injection): 讓用戶端可以隨需求override某些類別的內建預設行為, 這些內建預設的實作是在類別本身之內

## 4.1 組合根 Composition Root

- 要解決的問題: 該在何處做 __組合物件關聯__?
- A: 盡可能地在靠近application的流程啟動點, 去安排祖合物件關聯

### summary

- __Composition Root__ 指的是在application中的單一邏輯區塊位置, 在這邊會將各個模組組合起來.
- 在靠近application啟動點的地方, composition root會把鬆耦合架構下的實體物件關聯組合起來.
- composition root 可說是與系統中所有模組有著直接依賴關係的一處位置.
- 警告: 如果有採用DI container, composition root 就應該安排在使用 DI container的地方, 否則會形成 __Service Locator__ 這個反模式.
- Composition Root 不是一個方法, 也不是一種類別, 而是一種觀念. 集中application的一個區塊來組合這些類別.
- Composition Root 的本質就是專門針對一份application所編寫的, 並不是那種可重複利用的內容.
- 剩下的模組要注意不要在其中進行實體物件的組合作業, 其他模組中的class都應該採用 contructor injection (或其他)的設計模式
- Composition Root 應該是唯一能夠確實獲知物件關聯結構的地方
- 應該只讓 composition root 使用 DI container 技術, 至於其他部分的程式則不應該採用 DI container

### example

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddHttpContextAccessor();
    
    var connectionString = this.Configuration.GetConnectionString("CommerceConnection");
    
    services.AddSingleton<IControllerActivator>(new CommerceControllerActivator(connectionString));
}
```

### 依賴數量的暴增表象

- 組件檔之間的依賴其實是具有 __遞移性__ (Transitivity) 的


## 4.2 建構子注入 Constructor Injection

- 要解決的問題: 如何確保 class 所需要的不穩定 dependencies 對象即使不直接依賴, 但還是可以被滿足?
- A: 透過 class constructor, 以參數的形式要求呼叫方來滿足這些不穩定依賴的需求

- 定義: 在 class 的 constructor 方法識別定義中, 以參數列表的形式, 靜態定義出該類別的依賴需求

### 

```csharp
public class HomeController
{
    // 用來存放 dependency 對象物件的 private field
    private readonly IProductService service;
    
    // constructor 靜態定義了依賴需求, 透過參數提供 dependency 對象物件
    public HomeController(IProductService service)
    {
        // 避免呼叫端意外傳入null 的防禦性語句
        if(service == null)
            throw new ArgumentNullException("service");
        
        // 將dependency 對象物件存起來, 提供後續使用     
        this.service = service;
        
        // constructor 中, 除了驗證與保存injection外, 沒有其他程式邏輯
    }    
}
```

- 用於保存依賴對象的field 加上 readonly 修飾字, 在constructor 作業完成之後, 欄位的內容就不會再被更動
- 不要在 constructor 中加上其他程式邏輯, 不要對依賴對象進行任何處理

### 使用時機

- Constructor Injection 應該被視為 DI 架構的預設採用模式
- 因為大部分的情況都會有一到多個dependency需求存在, 而且沒有可使用的 __LOCAL DEFAULTS__ 選擇.
- Local Defaults(內建預設), 在同一份模組、或同一個架構層當中, 有著作為預設採用的依賴實作

### 優點

- 保障依賴關係能夠被滿足
- 實作門檻不高
- 可以明確地靜態定義出類別的依賴需求

### 缺點

- 如果採用的框架有著 Constrained Construction(限制性建構) 這個反模式存在, 實作 contructor injection 就會變得困難
- 類別的呼叫方是application 的框架, 就會需要針對該框架進行自訂, 才能支援你的constructor. 有些框架會預設 constructor 當中是沒有參數的

