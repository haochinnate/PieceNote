# Chapter 10: 設計面上的剖面導向程式設計

## 10.1 何謂剖面導向程式設計 AOP

- Aspect-Oriented Programming, 為了解決在實作 __橫切關切點__ 機制、以及其他設計模式時, 會出現的程式碼重複編寫問題.
- AOP 會先在單一定點實作這份設計模式後, 再以不需要修改其他既有程式碼的方式, 將這份模式套用到 code base 中其他需要的地方、或是乾脆集中於此單點處理.

### 錯誤範例

```csharp
// CircuitBreakerProductRepositoryDecorator class

public void Delete(Product product)
{
    this.breaker.Guard();

    try
    {
        this.decoratee.Delete(product);
        this.breaker.Succeed();
    }
    catch(Exception ex)
    {
        this.breaker.Trip(ex);
        throw;
    }
}

public void Insert(Product product)
{
    this.breaker.Guard();

    try
    {
        this.decoratee.Insert(product);
        this.breaker.Succeed();
    }
    catch(Exception ex)
    {
        this.breaker.Trip(ex);
        throw;
    }
}
```

### 常見的AOP實作方法 - SOLID

#### 說明

- 根據需要, 將剖面透過以抽象介面為中心的裝飾元件, 套用在一群類別上

#### 優點 

- 不需要工具輔助
- 易於實作
- 可讓心力專注於設計層面
- 系統更具可維護性

#### 缺點 

- 不一定能適用於傳統架構系統

### 常見的AOP實作方法 - 動態攔截

#### 說明

- 根據 application 內部的抽象介面, 於執行階段自動產生裝飾元件
- 這類裝飾元件會透過工具所提供的剖切面注入進去, 又稱之為 "攔截器"

#### 優點 

- 假設 application 架構已是以介面為中心的前提下, 只要稍作修改便能輕易套用在既有或是傳統架構的應用程式上
- 不需要擔心已編譯的application會與動態化的攔截函式庫產生緊耦合關係
- 免費工具中也有不錯的選擇

#### 缺點 

- 對剖面的實作會與使用的AOP工具無法分割
- 無法獲得編譯期階段的各項好處
- 容易造成不確定的行為與錯誤發生

### 常見的AOP實作方法 - 後編譯織入

#### 說明

- 在後期編譯階段流程中, 將剖面加入應用程式中. 這通常是以IL(Intermediate Language)連結的形式實現
- 透過一個外部工具, 讀取已編譯過的檔案, 在其中修改並加上剖面的實作, 把原先的內容替換為修改過的內容

#### 優點 

- 就算 application 並非以介面為中心的架構, 也只需要非常少量的修改就能輕易套用在既有或傳統架構的應用程式上

#### 缺點 

- 如果把不穩定依賴對象注入到剖面中, 將有可能造成時序耦合或是測試耦合的問題
- 由於是在後編譯期階段將剖面寫入進去, 因此不可能再呼叫到沒有被套用到剖面的程式碼版本. 這會提高測試的複雜度、並且降低彈性
- 而且後編譯期階段的連結其實與DI架構背道而馳

## 10.2 關於 SOLID 五原則

### Single Responsibility Principle

- 每個類別都只會有單一種理由, 讓你需要去修改它
- 內聚性: 在一個類別或是模組當中, 有多少比例的程式碼是在功能上相關聯的

### Open/Closed Principle

- 避免任何會對整份 code base 作出全面修改的可能性
- 對擴展保持開放, 對修改保持封閉
- 在不修改既有類別的原始碼前提下, 對系統的功能進行擴展

#### DRY: Don't Repeat Yourself

- 主要針對的是 __業務邏輯面__ 的修改
- 盡量把同樣、重覆的業務邏輯集中到同一處地方進行處理

### Liskov Substitution Principle

- 所有依賴對象都必須以抽象介面作為對外呈現的面貌
- 這樣才允許在同一種抽象介面下, 替換不同的實作, 而不用擔心依賴對象的使用方是否會因此發生異常
- 只要使用方仍持續以介面作為溝通的唯一管道, 不論介面背後是什麼實作都可以

### Interface Segregation Principle

- 提倡更精實, 而非包山包海的抽象介面
- 如果有使用方依賴於抽象介面, 卻覺得抽象介面中有多餘的成員, 那麼就表示這份抽象介面違反了ISP原則

### Dependency Inversion Principle

- 在編寫程式時, 要以抽象介面為中心, 決定抽象介面樣貌的是, 抽象介面的使用方
- 如果發現自己不是為了使用方, 而是為了某種特定的實體類別、或是將來可能的實體類別, 才在介面中增加成員的話, 可能就是違反 ISP

## 10.3 透過 SOLID 達成 AOP

- AOP 的主要目標: 保持橫切關切點遵循DRY原則
- 在設計面上達成AOP, 在被AOP工具綁死之前, 先試著利用設計模式與原則來達到目標

- 違反 SOLID 的 IProductService

```csharp

public interface IProductService
{
    IEnumerable<DiscountedProduct> GetFeaturedProducts();

    void DeleteProduct(Guid productId);
    Product GetProductById(Guid productId);
    void InsertProduct(Product product);
    void UpdateProduct(Product product);

    Paged<Product> SearchProducts(int pageIndex, int pageSize, Guid? manufacturerId, string searchText);
    void UpdateProductReviewTotals(Guid productId, ProductReview[] reviews);
    void AdjustInventory(Guid productId, bool decrease, int quantity);

    void UpdateHasTierPricesProperty(Product product);
    void UpdateHasDiscountsApplied(Guid productId, string discountDescription);
}

```

### 違反了 ISP 原則

- 包山包海的介面在 code base 中造成的問題與 __測試__ 有關
- 就算 HomeController 只用到 IProductService 中的一個 method, 在測試時定義的一個 實體類別, 仍需要實作介面中的所有 method

```csharp
public abstract class MockProductService : IProductService
{
    public IEnumerable<DiscountedProduct> GetFeaturedProducts()
    {
        // implement the function that used by HomeController when testing
    }
      
    public virtual void DeleteProduct(Guid productId)
    {
        Assert.True(false, "Should not be called");
    }

    public virtual Product GetProductById(Guid productId)
    {
        Assert.True(false, "Should not be called");
        return null;
    }

    // and other functions in IProductService, all have to be implemented
}
```

### 違反了 SRP 原則

- "與商品有關的操作": 此說法非常曖昧、模糊、與廣泛
- 底下的理由都可能導致 IProductService 的變更:
    - 修改折價優惠券的使用方式
    - 修改調整貨品數量的調整方式
    - 增加商品搜尋的資料搜尋範圍
    - 增加其他與商品有關的操作功能
- 驗證一個類別的內聚程度: 看有多少功能方法是可以輕易地切離成為一個新的類別
- 如果切離越是輕易, 就代表被切開的兩個部分關聯性越低, 代表違反SRP原則的可能性越高

### 違反了 OCP 原則

- 如何確認程式碼是否違反了 OCP 原則?
    1. 先思考在什麼可預期的情況下, 會修改到應用程式的這個部分
    2. 問自己: 當這個可預期的修改要進行時, 是否會因為目前這種設計而導致全面修改?
    3. 修改需求:
        1. 新功能的增加需求
        2. 引入屬於橫切關切點的機制

### 遵循 SOLID 來改善設計

#### 步驟

- 把讀取與寫入的動作分開
- 把介面與實作分開, 以便修正違反 ISP & SRP
- 利用參數物件與泛型介面設計, 以便修正違反 OCP
- 最後再以泛型抽象介面來修正過程中出現違反 LSP


## 10.4 小結

| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |